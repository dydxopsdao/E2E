name: E2E Pipeline

on:
  workflow_dispatch:
    inputs:
      deployment_id:
        description: 'Deployment ID'
        required: false
        default: 'manual'
  push:
    branches: [main]
  pull_request:
    branches: [main]

# Global environment
env:
  APPLITOOLS_API_KEY: ${{ secrets.APPLITOOLS_API_KEY }}
  APPLITOOLS_SERVER_URL: https://eyesapi.applitools.com

jobs:
  e2e-test:
    name: "E2E Tests (Deployment: ${{ inputs.deployment_id }})"
    runs-on: self-hosted

    # Provide a stable APPLITOOLS_BATCH_ID so Applitools doesn't throw an error.
    env:
      # For a PR, we use pull_request.head.sha; otherwise fallback to github.sha.
      APPLITOOLS_BATCH_ID: ${{ github.event.pull_request.head.sha || github.sha }}

      # Additional env vars for your tests
      NORDLAYER_EMAIL: ${{ secrets.NORDLAYER_EMAIL }}
      NORDLAYER_PASSWORD: ${{ secrets.NORDLAYER_PASSWORD }}
      SEED_PHRASE: ${{ secrets.SEED_PHRASE }}
      METAMASK_PASSWORD: ${{ secrets.METAMASK_PASSWORD }}
      DD_API_KEY: ${{ secrets.DD_API_KEY }}
      DD_SITE: ap1.datadoghq.com
      DD_SERVICE: dydx.trade
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DYDX_MNEMONIC: ${{ secrets.DYDX_MNEMONIC }}
      DYDX_ADDRESS: ${{ secrets.DYDX_ADDRESS }}
      DYDX_NETWORK_TYPE: mainnet
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      SLACK_CHANNEL: "#automated-testing-results"

    outputs:
      slack_ts: ${{ steps.slack-notify.outputs.slack_ts }}
      needs_review: ${{ steps.check-batch.outputs.needsReview }}
      found_batch_id: ${{ steps.check-batch.outputs.foundBatchID }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Dependencies
        run: |
          npm install
          npx playwright install chromium

      - name: Start Xvfb
        run: |
          Xvfb :99 -ac &>/dev/null &
          echo "DISPLAY=:99" >> $GITHUB_ENV
          sleep 3

      - name: Run E2E Tests (Playwright + Applitools)
        run: |
          PLAYWRIGHT_JUNIT_OUTPUT=results.xml \
          xvfb-run --auto-servernum --server-args='-screen 0 1920x1080x24' \
          npx playwright test

      # Upload test report artifacts if needed
      - name: Upload Test Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-test-report-${{ github.run_id }}
          path: playwright-report/

      # Optionally upload results to Datadog
      - name: Upload Test Results to Datadog
        if: always()
        run: |
          if [ -f results.xml ]; then
            echo "Uploading results.xml to Datadog..."
            # e.g. datadog-ci junit upload results.xml --service "$DD_SERVICE"
          else
            echo "results.xml not found, skipping Datadog upload."
          fi

      # Only check Applitools if E2E tests passed
      - name: Check Applitools Batch By Pointer
        if: success()
        id: check-batch
        run: |
          chmod +x scripts/checkApplitoolsBatchByPointer.sh
          ./scripts/checkApplitoolsBatchByPointer.sh \
            "${APPLITOOLS_SERVER_URL}" \
            "${APPLITOOLS_API_KEY}" \
            "${APPLITOOLS_BATCH_ID}"

      # Post Slack Notification (Always)
      - name: Post Slack Notification (Main Message)
        id: slack-notify
        if: always()
        env:
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          JOB_STATUS: ${{ job.status }}  # success/failure for E2E tests
          DEPLOYMENT_ID: ${{ inputs.deployment_id }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL: "#automated-testing-results"
          NEEDS_REVIEW: ${{ steps.check-batch.outputs.needsReview || 'false' }}
          FOUND_BATCH_ID: ${{ steps.check-batch.outputs.foundBatchID || '' }}
        run: |
          if [ "${JOB_STATUS}" = "success" ]; then
            # E2E tests passed
            if [ "${NEEDS_REVIEW}" = "true" ]; then
              # Applitools found differences
              MESSAGE="âœ… E2E Tests Passed!\n\n**Deployment ID:** ${DEPLOYMENT_ID}\nðŸ” *Visual differences detected â€“ manual review needed.*\n[Review in Applitools](https://eyes.applitools.com/app/test-results/${FOUND_BATCH_ID}/)"
            else
              # Applitools is all good (or check-batch didn't run)
              MESSAGE="âœ… E2E Tests Passed!\n\n**Deployment ID:** ${DEPLOYMENT_ID}\nðŸŽ‰ *All visual checks passed. Rollout can proceed.*"
            fi
          else
            # E2E tests failed
            MESSAGE="âŒ E2E Tests Failed!\n\n**Deployment ID:** ${DEPLOYMENT_ID}\n[Details & Logs](${RUN_URL})"
          fi

          RESPONSE=$(curl -s -X POST \
            -H "Content-type: application/json" \
            -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
            --data "{
              \"channel\": \"${SLACK_CHANNEL}\",
              \"text\": \"${MESSAGE}\"
            }" \
            https://slack.com/api/chat.postMessage)

          # Capture the Slack message timestamp so we can post a thread if needed
          TS=$(echo "$RESPONSE" | jq -r '.ts')
          echo "slack_ts=${TS}" >> $GITHUB_OUTPUT

  # If Applitools is all good, auto-complete the batch & optionally post a thread with links
  applitools-auto-complete:
    name: "Applitools Auto-Completion"
    if: needs.e2e-test.outputs.needs_review == 'false'
    needs: e2e-test
    runs-on: ubuntu-latest

    steps:
      - name: Mark Applitools Batch as Complete
        run: |
          echo "No review needed, auto-completing the batch."
          curl -X POST -d '' -H "accept:*/*" \
            "${{ env.APPLITOOLS_SERVER_URL }}/api/externals/github/servers/github.com/commit/${{ needs.e2e-test.outputs.found_batch_id }}/complete?apiKey=${{ env.APPLITOOLS_API_KEY }}"

      - name: Post Slack Thread (All Passed)
        env:
          THREAD_TS: ${{ needs.e2e-test.outputs.slack_ts }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL: "#automated-testing-results"
          FOUND_BATCH_ID: ${{ needs.e2e-test.outputs.found_batch_id }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          # Provide direct links to GitHub Actions and Applitools in a Slack thread
          APPLITOOLS_LINK="https://eyes.applitools.com/app/test-results/${FOUND_BATCH_ID}/"
          GITHUB_RUN_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          THREAD_MESSAGE="Additional details:\n- GitHub Action: ${GITHUB_RUN_URL}\n- Applitools: ${APPLITOOLS_LINK}"
          
          curl -s -X POST \
            -H "Content-type: application/json" \
            -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
            --data "{
              \"channel\": \"${SLACK_CHANNEL}\",
              \"text\": \"${THREAD_MESSAGE}\",
              \"thread_ts\": \"${THREAD_TS}\"
            }" \
            https://slack.com/api/chat.postMessage

  # If Applitools has differences, poll for status resolution
  batch-status-polling:
    name: "Applitools Batch Status Polling"
    if: needs.e2e-test.outputs.needs_review == 'true'
    needs: e2e-test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository 
        uses: actions/checkout@v4
      
      - name: Poll Applitools Batch Status
        id: poll-status
        env:
          THREAD_TS: ${{ needs.e2e-test.outputs.slack_ts }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
          SLACK_CHANNEL: "#automated-testing-results"
          FOUND_BATCH_ID: ${{ needs.e2e-test.outputs.found_batch_id }}
          APPLITOOLS_API_KEY: ${{ secrets.APPLITOOLS_API_KEY }}
          APPLITOOLS_SERVER_URL: ${{ env.APPLITOOLS_SERVER_URL }}
        run: |
          # Create helper function to send Slack messages
          send_slack_message() {
            local message="$1"
            local ts="${THREAD_TS}"
            
            # Escape special characters in the message
            escaped_message=$(echo "$message" | sed 's/"/\\"/g')
            
            curl -s -X POST \
              -H "Content-type: application/json" \
              -H "Authorization: Bearer ${SLACK_BOT_TOKEN}" \
              --data "{
                \"channel\": \"${SLACK_CHANNEL}\",
                \"text\": \"${escaped_message}\",
                \"thread_ts\": \"${ts}\"
              }" \
              https://slack.com/api/chat.postMessage
          }
          
          # Post initial message
          APPLITOOLS_LINK="https://eyes.applitools.com/app/test-results/${FOUND_BATCH_ID}/"
          GITHUB_RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          INITIAL_MESSAGE="âš ï¸ **Visual differences detected**\n\nðŸ” *Waiting for manual review...*\n[Review in Applitools](${APPLITOOLS_LINK})\nâ³ This job will monitor for **up to 1 hour**."
          send_slack_message "${INITIAL_MESSAGE}"
          
          # Poll status for up to 1 hour (120 attempts Ã— 30 seconds = 3600 seconds)
          MAX_ATTEMPTS=120
          ATTEMPT=0
          POLL_INTERVAL=30
          FINAL_STATUS=""
          
          while [ "$ATTEMPT" -lt "$MAX_ATTEMPTS" ]; do
            ATTEMPT=$((ATTEMPT + 1))
            echo "Polling attempt $ATTEMPT of $MAX_ATTEMPTS..."
            
            # Get batch status using the same endpoint as checkApplitoolsBatchByPointer.sh
            START_DATE="$(date -u -d '1 day ago' +%Y-%m-%dT%H:%M:%SZ)"
            END_DATE="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
            
            RESPONSE=$(curl -s -X GET \
              -H "X-Eyes-Api-Key: ${APPLITOOLS_API_KEY}" \
              "${APPLITOOLS_SERVER_URL}/api/v1/batches?start=${START_DATE}&end=${END_DATE}&pageSize=100")
            
            # Extract batch info using jq
            BATCH_INFO=$(echo "$RESPONSE" | jq --arg bid "${FOUND_BATCH_ID}" '.batches[] | select(.id == $bid)')
            
            if [ -z "$BATCH_INFO" ]; then
              echo "Warning: Batch ${FOUND_BATCH_ID} not found in response"
              sleep "$POLL_INTERVAL"
              continue
            fi
            
            # Extract status information
            FAILED=$(echo "$BATCH_INFO" | jq -r '.failed')
            UNRESOLVED=$(echo "$BATCH_INFO" | jq -r '.unresolved')
            NEW=$(echo "$BATCH_INFO" | jq -r '.new')
            STATUS=$(echo "$BATCH_INFO" | jq -r '.status')
            
            echo "Current batch status: $STATUS"
            echo "Failed: $FAILED, Unresolved: $UNRESOLVED, New: $NEW"
            
            # Check if status is resolved
            if [ "$STATUS" = "Passed" ] && [ "$FAILED" -eq 0 ] && [ "$UNRESOLVED" -eq 0 ] && [ "$NEW" -eq 0 ]; then
              FINAL_STATUS="PASSED"
              break
            elif [ "$FAILED" -gt 0 ]; then
              FINAL_STATUS="FAILED"
              break
            elif [ "$STATUS" = "Completed" ]; then
              FINAL_STATUS="COMPLETED"
              break
            fi
            
            # Status still unresolved, wait and try again
            sleep "$POLL_INTERVAL"
          done
          
          # Handle final status
          if [ "$FINAL_STATUS" = "PASSED" ]; then
            FINAL_MESSAGE="âœ… **Visual Review Approved**\n\nðŸŽ‰ *All differences approved â€“ rollout can proceed.*\n\nðŸ”— [GitHub Action](${GITHUB_RUN_URL}) | [Applitools](${APPLITOOLS_LINK})"
            send_slack_message "${FINAL_MESSAGE}"
            echo "status=approved" >> "$GITHUB_OUTPUT"
          elif [ "$FINAL_STATUS" = "FAILED" ]; then
            FINAL_MESSAGE="âŒ **Visual Review Rejected**\n\nðŸš¨ *Differences were not approved â€“ rollout stopped.*\n\nðŸ”— [GitHub Action](${GITHUB_RUN_URL}) | [Applitools](${APPLITOOLS_LINK})"
            send_slack_message "${FINAL_MESSAGE}"
            echo "status=rejected" >> "$GITHUB_OUTPUT"
          elif [ "$FINAL_STATUS" = "COMPLETED" ]; then
            FINAL_MESSAGE="âœ… **Batch Marked as Completed**\n\nðŸš€ *Proceeding with rollout.*\n\nðŸ”— [GitHub Action](${GITHUB_RUN_URL}) | [Applitools](${APPLITOOLS_LINK})"
            send_slack_message "${FINAL_MESSAGE}"
            echo "status=approved" >> "$GITHUB_OUTPUT"
          else
            # Timeout reached, still unresolved
            FINAL_MESSAGE="âš ï¸ **Batch Review Timed Out**\n\nâ³ *Review was not completed within 1 hour.*\nðŸ” Please check manually and re-run if needed.\n\nðŸ”— [GitHub Action](${GITHUB_RUN_URL}) | [Applitools](${APPLITOOLS_LINK})"
            send_slack_message "${FINAL_MESSAGE}"
            echo "status=timeout" >> "$GITHUB_OUTPUT"
      
      - name: Mark Applitools Batch as Complete
        if: steps.poll-status.outputs.status == 'approved'
        run: |
          echo "Completing the batch after approval."
          curl -X POST -d '' -H "accept:*/*" \
            "${{ env.APPLITOOLS_SERVER_URL }}/api/externals/github/servers/github.com/commit/${{ needs.e2e-test.outputs.found_batch_id }}/complete?apiKey=${{ env.APPLITOOLS_API_KEY }}"
      
      - name: Fail Workflow if Review Rejected
        if: steps.poll-status.outputs.status == 'rejected'
        run: |
          echo "Visual tests were rejected. Failing the workflow."
          exit 1
