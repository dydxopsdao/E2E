name: E2E Pipeline

on:
  workflow_dispatch:
    inputs:
      deployment_id:
        description: 'Deployment ID'
        required: false
        default: 'manual'
  pull_request:

# Global environment
env:
  APPLITOOLS_API_KEY: ${{ secrets.APPLITOOLS_API_KEY }}
  APPLITOOLS_SERVER_URL: https://eyesapi.applitools.com

jobs:
  e2e-test:
    name: "E2E Tests (Deployment: ${{ inputs.deployment_id }})"
    runs-on: self-hosted

    env:
      # batch id for Applitools
      APPLITOOLS_BATCH_ID: ${{ github.event.pull_request.head.sha || github.sha }}
      # manual → #test-channel; else → engineering channel ID
      SLACK_CHANNEL: ${{ inputs.deployment_id == 'manual' && '#test-channel' || 'C07VDF07WLU' }}
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      NORDLAYER_EMAIL: ${{ secrets.NORDLAYER_EMAIL }}
      NORDLAYER_PASSWORD: ${{ secrets.NORDLAYER_PASSWORD }}
      SEED_PHRASE: ${{ secrets.SEED_PHRASE }}
      METAMASK_PASSWORD: ${{ secrets.METAMASK_PASSWORD }}
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      DYDX_MNEMONIC: ${{ secrets.DYDX_MNEMONIC }}
      DYDX_ADDRESS: ${{ secrets.DYDX_ADDRESS }}
      DYDX_NETWORK_TYPE: mainnet
      SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      DYDX_MNEMONIC_CANCEL_ORDER: ${{ secrets.DYDX_MNEMONIC_CANCEL_ORDER }}
      DYDX_ADDRESS_CANCEL_ORDER: ${{ secrets.DYDX_ADDRESS_CANCEL_ORDER }}
      SEED_PHRASE_CANCEL_ORDER: ${{ secrets.SEED_PHRASE_CANCEL_ORDER }}
      SEED_PHRASE_MEGAVAULT: ${{ secrets.SEED_PHRASE_MEGAVAULT }}engio
    outputs:
      slack_ts: ${{ steps.slack-notify.outputs.slack_ts }}
      needs_review: ${{ steps.check-batch.outputs.needsReview }}
      found_batch_id: ${{ steps.check-batch.outputs.foundBatchID }}
      slack_channel: ${{ env.SLACK_CHANNEL }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT_FOR_CHECKOUT }}
          fetch-depth: 5

      - name: Install Dependencies
        run: npm install
        env:
          PLAYWRIGHT_BROWSERS_PATH: /opt/playwright

      # ─────────────────────────────────────────────────────────
      # 1) “Tests started” ping, threaded for non-manual IDs
      - name: Post “Tests started” to Slack
        id: slack-started
        if: ${{ inputs.deployment_id != 'manual' }}
        run: |
          TEXT="🏁 E2E tests started for **Deployment ID:** ${{ inputs.deployment_id }}"
          CHANNEL="$SLACK_CHANNEL"

          # Fetch the channel history.
          HISTORY_RESPONSE=$(curl -s -G \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            --data-urlencode "channel=$CHANNEL" \
            --data-urlencode "limit=200" \
            "https://slack.com/api/conversations.history")

          # This is the corrected jq filter.
          # It selects the MESSAGE object if ANY of its attachments have a matching fallback text.
          JQ_FILTER='
            if .ok then .messages[] else empty end |
            select(any(.attachments[]; .fallback? | test("release/" + $id; "i"))) |
            .ts
          '
          
          # Attempt to extract the timestamp from the response.
          THREAD_TS=$(echo "$HISTORY_RESPONSE" | jq -r --arg id "${{ inputs.deployment_id }}" "$JQ_FILTER" | head -n1)

          if [ -n "$THREAD_TS" ]; then
            echo "Found thread TS: ${THREAD_TS}. Posting threaded reply."
            curl -s -X POST \
              -H "Content-type: application/json" \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              --data "{\"channel\":\"${CHANNEL}\",\"thread_ts\":\"${THREAD_TS}\",\"text\":\"${TEXT}\"}" \
              https://slack.com/api/chat.postMessage
          else
            echo "--- WARNING: Thread not found for release/${{ inputs.deployment_id }}. Skipping 'tests started' message. ---"
          fi

      # ─────────────────────────────────────────────────────────
      - name: Run E2E Tests (Playwright + Applitools)
        env:
          DEPLOYMENT_ID: ${{ inputs.deployment_id }}
        run: |
          PLAYWRIGHT_JUNIT_OUTPUT=results.xml xvfb-run --auto-servernum \
            --server-args='-screen 0 1920x1080x24' \
            npx playwright test --workers=2

      - name: Upload Test Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-test-report-${{ github.run_id }}
          path: playwright-report/

      - name: Check Applitools Batch By Pointer
        if: always()
        id: check-batch
        run: |
          chmod +x scripts/checkApplitoolsBatchByPointer.sh
          ./scripts/checkApplitoolsBatchByPointer.sh \
            "$APPLITOOLS_SERVER_URL" \
            "$APPLITOOLS_API_KEY" \
            "$APPLITOOLS_BATCH_ID"

      # ─────────────────────────────────────────────────────────
      # 2) Find the release thread (only for non-manual runs)
      - name: Find release thread in engineering
        id: find-thread
        if: ${{ inputs.deployment_id != 'manual' }}
        run: |
          # Fetch the channel history.
          HISTORY_RESPONSE=$(curl -s -G \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            --data-urlencode "channel=$SLACK_CHANNEL" \
            --data-urlencode "limit=200" \
            "https://slack.com/api/conversations.history")

          # It selects the MESSAGE object if ANY of its attachments have a matching fallback text.
          JQ_FILTER='
            if .ok then .messages[] else empty end |
            select(any(.attachments[]; .fallback? | test("release/" + $id; "i"))) |
            .ts
          '
          
          # Attempt to extract the timestamp from the response.
          THREAD_TS=$(echo "$HISTORY_RESPONSE" | jq -r --arg id "${{ inputs.deployment_id }}" "$JQ_FILTER" | head -n1)

          if [ -n "$THREAD_TS" ]; then
            echo "Found thread TS for results: ${THREAD_TS}"
            echo "thread_ts=$THREAD_TS" >> $GITHUB_OUTPUT
          else
            echo "Warning: no release thread found for release/${{ inputs.deployment_id }} during the 'Find release thread' step."
          fi

      # ─────────────────────────────────────────────────────────
      # 3) Post final ✅/❌, de-dupe, and thread if possible
      - name: Post Slack Notification (Main Message)
        id: slack-notify
        if: always()
        run: |
          # --- SAFTY CHECK for automated runs ---
          # For non-manual runs, if no thread was found, do not post the results at all.
          if [ "${{ inputs.deployment_id }}" != "manual" ] && [ -z "${{ steps.find-thread.outputs.thread_ts }}" ]; then
            echo "Warning: Not a manual run and release thread was not found. Skipping final Slack notification to avoid spamming the main channel."
            exit 0
          fi

          # build the message text
          if [ "${{ job.status }}" = "success" ]; then
            if [ "${{ steps.check-batch.outputs.needsReview }}" = "true" ]; then
              ICON="🔍 *Visual diffs detected – manual review needed.*"
            else
              ICON="🎉 *All visual checks passed. Rollout can proceed.*"
            fi
            TEXT="✅ E2E Tests Passed!\n\n**Deployment ID:** ${{ inputs.deployment_id }}\n${ICON}"
          else
            TEXT="❌ E2E Tests Failed!\n\n**Deployment ID:** ${{ inputs.deployment_id }}\n[Details & Logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})"
          fi

          # if we found a thread, check for duplicates
          THREAD_TS="${{ steps.find-thread.outputs.thread_ts }}"
          if [ -n "$THREAD_TS" ]; then
            DUP=$(curl -s -G \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              --data-urlencode "channel=$SLACK_CHANNEL" \
              --data-urlencode "ts=$THREAD_TS" \
              "https://slack.com/api/conversations.replies" \
            | jq -r --arg txt "$TEXT" \
                '.messages[] | select(.text == $txt) | .ts')
            if [ -n "$DUP" ]; then
              echo "Already posted in thread $THREAD_TS; skipping."
              exit 0
            fi
          fi

          # assemble payload (+thread_ts if set)
          PAYLOAD="{\"channel\":\"$SLACK_CHANNEL\","
          if [ -n "$THREAD_TS" ]; then
            PAYLOAD+="\"thread_ts\":\"$THREAD_TS\","
          fi
          PAYLOAD+="\"text\":\"$TEXT\"}"

          # post it
          RESPONSE=$(curl -s -X POST \
            -H "Content-type: application/json" \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            --data "$PAYLOAD" \
            https://slack.com/api/chat.postMessage)

          # capture the ts
          echo "slack_ts=$(echo \"$RESPONSE\" | jq -r .ts)" >> $GITHUB_OUTPUT

  # ─────────────────────────────────────────────────────────
  applitools-auto-complete:
    name: "Applitools Auto-Completion"
    if: needs.e2e-test.outputs.needs_review == 'false'
    needs: e2e-test
    runs-on: ubuntu-latest

    env:
      SLACK_CHANNEL: ${{ needs.e2e-test.outputs.slack_channel }}
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      APPLITOOLS_API_KEY: ${{ secrets.APPLITOOLS_API_KEY }}

    steps:
      - name: Mark Applitools Batch as Complete
        run: |
          curl -X POST -d '' -H 'accept:*/*' \
            "$APPLITOOLS_SERVER_URL/api/externals/github/servers/github.com/commit/${{ needs.e2e-test.outputs.found_batch_id }}/complete?apiKey=$APPLITOOLS_API_KEY"

      - name: Post Slack Thread (All Passed)
        run: |
          THREAD_TS=${{ needs.e2e-test.outputs.slack_ts }}
          APPLITOOLS_LINK="https://eyes.applitools.com/app/test-results/${{ needs.e2e-test.outputs.found_batch_id }}/"
          GITHUB_RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          MSG="Additional details:\n- GitHub Action: ${GITHUB_RUN_URL}\n- Applitools: ${APPLITOOLS_LINK}"
          curl -s -X POST \
            -H "Content-type: application/json" \
            -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
            --data "{\"channel\":\"$SLACK_CHANNEL\",\"thread_ts\":\"$THREAD_TS\",\"text\":\"$MSG\"}" \
            https://slack.com/api/chat.postMessage

  # ─────────────────────────────────────────────────────────
  batch-status-polling:
    name: "Applitools Batch Status Polling"
    if: needs.e2e-test.outputs.needs_review == 'true'
    needs: e2e-test
    runs-on: ubuntu-latest

    env:
      SLACK_CHANNEL: ${{ needs.e2e-test.outputs.slack_channel }}
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      APPLITOOLS_API_KEY: ${{ secrets.APPLITOOLS_API_KEY }}

    steps:
      - uses: actions/checkout@v4

      - name: Poll Applitools Batch Status
        id: poll-status
        run: |
          send_slack_message() {
            local msg="$1"; local ts="${{ needs.e2e-test.outputs.slack_ts }}"
            esc=$(echo "$msg" | sed 's/"/\\"/g' | sed "s/'/\\'/g")
            curl -s -X POST \
              -H "Content-type: application/json" \
              -H "Authorization: Bearer $SLACK_BOT_TOKEN" \
              --data "{\"channel\":\"$SLACK_CHANNEL\",\"thread_ts\":\"$ts\",\"text\":\"$esc\"}" \
              https://slack.com/api/chat.postMessage
          }

          APPLITOOLS_LINK="https://eyes.applitools.com/app/test-results/${{ needs.e2e-test.outputs.found_batch_id }}/"
          GITHUB_RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          send_slack_message "⚠️ **Visual differences detected**\n\n🔍 *Waiting for manual review...*\n[Review in Applitools](${APPLITOOLS_LINK})\n⏳ Monitoring up to 1h."

          MAX=120; I=0; INTERVAL=30; STATUS=""
          while [ "$I" -lt "$MAX" ]; do
            I=$((I+1))
            START=$(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%SZ)
            END=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            RESP=$(curl -s -X GET \
              -H "X-Eyes-Api-Key: $APPLITOOLS_API_KEY" \
              "$APPLITOOLS_SERVER_URL/api/v1/batches?start=$START&end=$END&pageSize=100")
            B=$(echo "$RESP" | jq --arg bid "${{ needs.e2e-test.outputs.found_batch_id }}" \
                  '.batches[]|select(.id==$bid)')
            if [ -z "$B" ] || [ "$B" = "null" ]; then sleep "$INTERVAL"; continue; fi

            F=$(echo "$B" | jq -r '.runningSummary.failedTests // .statusSummary.Failed // 0')
            U=$(echo "$B" | jq -r '.runningSummary.unresolvedTests // .statusSummary.Unresolved // 0')
            N=$(echo "$B" | jq -r '.runningSummary.newTests // .statusSummary.New // 0')

            if [ "$F" -gt 0 ]; then STATUS="FAILED"; break; fi
            if [ "$F" -eq 0 ] && [ "$U" -eq 0 ] && [ "$N" -eq 0 ]; then STATUS="PASSED"; break; fi
            sleep "$INTERVAL"
          done

          if [ "$STATUS" = "PASSED" ]; then
            send_slack_message "✅ **Visual Review Approved**\n\n🎉 Rollout can proceed.\n\n🔗 [Action](${GITHUB_RUN_URL}) | [Applitools](${APPLITOOLS_LINK})"
            echo "status=approved" >> $GITHUB_OUTPUT
          elif [ "$STATUS" = "FAILED" ]; then
            send_slack_message "❌ **Visual Review Rejected**\n\n🚨 Rollout stopped.\n\n🔗 [Action](${GITHUB_RUN_URL}) | [Applitools](${APPLITOOLS_LINK})"
            echo "status=rejected" >> $GITHUB_OUTPUT
          else
            send_slack_message "⚠️ **Review timed out/has issues**\n\n⏳ Please check manually.\n\n🔗 [Action](${GITHUB_RUN_URL}) | [Applitools](${APPLITOOLS_LINK})"
            echo "status=timeout" >> $GITHUB_OUTPUT
          fi

      - name: Mark Applitools Batch as Complete
        if: steps.poll-status.outputs.status == 'approved'
        run: |
          curl -X POST -d '' -H 'accept:*/*' \
            "$APPLITOOLS_SERVER_URL/api/externals/github/servers/github.com/commit/${{ needs.e2e-test.outputs.found_batch_id }}/complete?apiKey=$APPLITOOLS_API_KEY"

      - name: Fail Workflow if Review Rejected
        if: steps.poll-status.outputs.status == 'rejected'
        run: exit 1